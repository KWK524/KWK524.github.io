<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GPS ê²½ë¡œ ì¶”ì ê¸°</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #111;
            color: #fff;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        #header {
            background: #1f2937;
            padding: 1rem;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        h1 {
            font-size: 1.5rem;
            font-weight: bold;
        }
        #main {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 1rem;
            gap: 1rem;
            overflow-y: auto;
        }
        #canvas-container {
            background: #1f2937;
            border-radius: 0.5rem;
            overflow: hidden;
            flex: 1;
            min-height: 300px;
            position: relative;
            touch-action: none;
        }
        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        #scale-indicator {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            font-family: monospace;
            pointer-events: none;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.75rem;
        }
        .stat-card {
            background: #1f2937;
            padding: 0.75rem;
            border-radius: 0.5rem;
        }
        .stat-label {
            font-size: 0.75rem;
            color: #9ca3af;
            margin-bottom: 0.25rem;
        }
        .stat-value {
            font-size: 1.25rem;
            font-weight: bold;
        }
        .location-info {
            background: #1f2937;
            padding: 0.75rem;
            border-radius: 0.5rem;
            font-size: 0.875rem;
            font-family: monospace;
        }
        .location-label {
            color: #9ca3af;
            margin-bottom: 0.25rem;
        }
        .toggle-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: #1f2937;
            padding: 0.75rem;
            border-radius: 0.5rem;
        }
        .toggle-label {
            font-size: 0.875rem;
            color: #9ca3af;
        }
        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
            background: #374151;
            border-radius: 13px;
            cursor: pointer;
            transition: background 0.3s;
        }
        .toggle-switch.active {
            background: #3b82f6;
        }
        .toggle-slider {
            position: absolute;
            top: 3px;
            left: 3px;
            width: 20px;
            height: 20px;
            background: #fff;
            border-radius: 50%;
            transition: transform 0.3s;
        }
        .toggle-switch.active .toggle-slider {
            transform: translateX(24px);
        }
        .controls {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 0.75rem;
        }
        button {
            padding: 1rem;
            border: none;
            border-radius: 0.5rem;
            font-size: 1.125rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        button:active {
            transform: scale(0.98);
        }
        #startBtn {
            background: #10b981;
            color: #fff;
        }
        #startBtn:active {
            background: #059669;
        }
        #startBtn.tracking {
            background: #ef4444;
        }
        #startBtn.tracking:active {
            background: #dc2626;
        }
        #resetBtn {
            background: #374151;
            color: #fff;
        }
        #resetBtn:active {
            background: #4b5563;
        }
        #resetBtn:disabled {
            background: #1f2937;
            color: #6b7280;
        }
        #downloadBtn {
            background: #3b82f6;
            color: #fff;
            grid-column: 1 / -1;
        }
        #downloadBtn:active {
            background: #2563eb;
        }
        #downloadBtn:disabled {
            background: #1f2937;
            color: #6b7280;
        }
        .error {
            background: rgba(239, 68, 68, 0.2);
            border: 1px solid #ef4444;
            color: #fca5a5;
            padding: 0.75rem;
            border-radius: 0.5rem;
            font-size: 0.875rem;
        }
        .info {
            background: #1f2937;
            padding: 0.75rem;
            border-radius: 0.5rem;
            font-size: 0.75rem;
            color: #9ca3af;
        }
        .info strong {
            color: #fff;
        }
        .hidden {
            display: none;
        }

    </style>
</head>
<body>
    <div id="header">
        <h1>ğŸ“ GPS ê²½ë¡œ ì¶”ì ê¸°</h1>
    </div>

    <div id="main">
        <div id="canvas-container">
            <canvas id="canvas"></canvas>
            <div id="scale-indicator">ì¶•ì²™: ê³„ì‚°ì¤‘...</div>
        </div>

        <div class="toggle-container">
            <span class="toggle-label">ë³´ì •ëœ ê²½ë¡œ í‘œì‹œ</span>
            <div id="togglePath" class="toggle-switch">
                <div class="toggle-slider"></div>
            </div>
        </div>

        <div class="stats">
            <div class="stat-card">
                <div class="stat-label">ê¸°ë¡ì </div>
                <div class="stat-value" id="pointCount">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">ê±°ë¦¬</div>
                <div class="stat-value" id="distance">0.00km</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">ì‹œê°„</div>
                <div class="stat-value" id="time">0:00:00</div>
            </div>
        </div>

        <div id="locationInfo" class="location-info hidden">
            <div class="location-label">í˜„ì¬ ìœ„ì¹˜</div>
            <div id="locationText"></div>
        </div>

        <div class="controls">
            <button id="startBtn">â–¶ ì‹œì‘</button>
            <button id="resetBtn">â†»</button>
        </div>

        <button id="downloadBtn" disabled>ğŸ’¾ ë°ì´í„° ì €ì¥</button>

        <div id="error" class="error hidden"></div>

        <div class="info">
            <strong>ğŸ’¡ ì‚¬ìš© íŒ</strong><br>
            â€¢ ìº”ë²„ìŠ¤ë¥¼ í•€ì¹˜/ë“œë˜ê·¸ë¡œ í™•ëŒ€/ì¶•ì†Œ/ì´ë™<br>
            â€¢ ë…¹ìƒ‰=ì‹œì‘ì , ë¹¨ê°•=í˜„ì¬ìœ„ì¹˜<br>
            â€¢ ë³´ì • ê²½ë¡œëŠ” ì§ì„ í™”ëœ ê¹”ë”í•œ ê²½ë¡œì…ë‹ˆë‹¤
        </div>
    </div>



    <script>
        let isTracking = false;
        let points = [];
        let watchId = null;
        let startTime = null;
        let timerInterval = null;
        let totalDistance = 0;
        let showCorrectedPath = false;

        // ìº”ë²„ìŠ¤ ì œì–´
        let scale = 1;
        let offsetX = 0;
        let offsetY = 0;
        let isDragging = false;
        let lastTouchX = 0;
        let lastTouchY = 0;
        let lastTouchDist = 0;

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const startBtn = document.getElementById('startBtn');
        const resetBtn = document.getElementById('resetBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const errorDiv = document.getElementById('error');
        const locationInfo = document.getElementById('locationInfo');
        const locationText = document.getElementById('locationText');
        const togglePath = document.getElementById('togglePath');
        const scaleIndicator = document.getElementById('scale-indicator');

        // í† ê¸€
        togglePath.addEventListener('click', () => {
            showCorrectedPath = !showCorrectedPath;
            togglePath.classList.toggle('active');
            drawPath();
        });

        // ìº”ë²„ìŠ¤ í¬ê¸° ì„¤ì •
        function resizeCanvas() {
            const container = document.getElementById('canvas-container');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            drawPath();
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // í„°ì¹˜/ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸
        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('touchstart', handleStart);
        canvas.addEventListener('touchmove', handleMove);
        canvas.addEventListener('touchend', handleEnd);
        canvas.addEventListener('wheel', handleWheel, { passive: false });

        function getTouchDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function handleStart(e) {
            e.preventDefault();
            if (e.touches && e.touches.length === 2) {
                lastTouchDist = getTouchDistance(e.touches);
            } else {
                isDragging = true;
                const pos = e.touches ? e.touches[0] : e;
                lastTouchX = pos.clientX;
                lastTouchY = pos.clientY;
            }
        }

        function handleMove(e) {
            e.preventDefault();
            if (e.touches && e.touches.length === 2) {
                const dist = getTouchDistance(e.touches);
                const delta = dist - lastTouchDist;
                const newScale = scale * (1 + delta * 0.01);
                scale = Math.max(0.5, Math.min(10, newScale));
                lastTouchDist = dist;
                drawPath();
            } else if (isDragging) {
                const pos = e.touches ? e.touches[0] : e;
                const dx = pos.clientX - lastTouchX;
                const dy = pos.clientY - lastTouchY;
                offsetX += dx;
                offsetY += dy;
                lastTouchX = pos.clientX;
                lastTouchY = pos.clientY;
                drawPath();
            }
        }

        function handleEnd(e) {
            isDragging = false;
        }

        function handleWheel(e) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            scale = Math.max(0.5, Math.min(10, scale * delta));
            drawPath();
        }

        // ê±°ë¦¬ ê³„ì‚° (Haversine)
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371e3;
            const Ï†1 = lat1 * Math.PI / 180;
            const Ï†2 = lat2 * Math.PI / 180;
            const Î”Ï† = (lat2 - lat1) * Math.PI / 180;
            const Î”Î» = (lon2 - lon1) * Math.PI / 180;

            const a = Math.sin(Î”Ï†/2) * Math.sin(Î”Ï†/2) +
                      Math.cos(Ï†1) * Math.cos(Ï†2) *
                      Math.sin(Î”Î»/2) * Math.sin(Î”Î»/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

            return R * c;
        }

        // ê²½ë¡œ ë³´ì • (Douglas-Peucker ì•Œê³ ë¦¬ì¦˜ ë‹¨ìˆœí™”)
        function simplifyPath(points, tolerance = 0.00005) {
            if (points.length <= 2) return points;

            function perpendicularDistance(point, lineStart, lineEnd) {
                const dx = lineEnd.lon - lineStart.lon;
                const dy = lineEnd.lat - lineStart.lat;
                const mag = Math.sqrt(dx * dx + dy * dy);
                if (mag === 0) return Math.sqrt(Math.pow(point.lon - lineStart.lon, 2) + Math.pow(point.lat - lineStart.lat, 2));
                const u = ((point.lon - lineStart.lon) * dx + (point.lat - lineStart.lat) * dy) / (mag * mag);
                const x = lineStart.lon + u * dx;
                const y = lineStart.lat + u * dy;
                return Math.sqrt(Math.pow(point.lon - x, 2) + Math.pow(point.lat - y, 2));
            }

            function simplify(points, start, end, tolerance, result) {
                let maxDist = 0;
                let maxIndex = 0;

                for (let i = start + 1; i < end; i++) {
                    const dist = perpendicularDistance(points[i], points[start], points[end]);
                    if (dist > maxDist) {
                        maxDist = dist;
                        maxIndex = i;
                    }
                }

                if (maxDist > tolerance) {
                    simplify(points, start, maxIndex, tolerance, result);
                    result.push(points[maxIndex]);
                    simplify(points, maxIndex, end, tolerance, result);
                }
            }

            const result = [points[0]];
            simplify(points, 0, points.length - 1, tolerance, result);
            result.push(points[points.length - 1]);
            return result;
        }

        // ê²½ë¡œ ê·¸ë¦¬ê¸°
        function drawPath() {
            const width = canvas.width;
            const height = canvas.height;

            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, width, height);

            if (points.length === 0) {
                ctx.fillStyle = '#6b7280';
                ctx.font = '16px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('ì¶”ì ì„ ì‹œì‘í•˜ì„¸ìš”', width / 2, height / 2);
                updateScaleIndicator(0);
                return;
            }

            const displayPoints = showCorrectedPath ? simplifyPath(points, 0.00003) : points;

            if (displayPoints.length === 1) {
                ctx.save();
                ctx.translate(offsetX, offsetY);
                ctx.scale(scale, scale);
                ctx.fillStyle = '#10b981';
                ctx.beginPath();
                ctx.arc(width / 2, height / 2, 10, 0, 2 * Math.PI);
                ctx.fill();
                ctx.restore();
                updateScaleIndicator(0);
                return;
            }

            const lats = displayPoints.map(p => p.lat);
            const lons = displayPoints.map(p => p.lon);
            const minLat = Math.min(...lats);
            const maxLat = Math.max(...lats);
            const minLon = Math.min(...lons);
            const maxLon = Math.max(...lons);

            const latRange = maxLat - minLat || 0.001;
            const lonRange = maxLon - minLon || 0.001;

            const padding = 30;
            const drawWidth = width - 2 * padding;
            const drawHeight = height - 2 * padding;

            function toCanvas(lat, lon) {
                const x = padding + ((lon - minLon) / lonRange) * drawWidth;
                const y = height - padding - ((lat - minLat) / latRange) * drawHeight;
                return { x, y };
            }

            ctx.save();
            ctx.translate(width / 2 + offsetX, height / 2 + offsetY);
            ctx.scale(scale, scale);
            ctx.translate(-width / 2, -height / 2);

            // ì›ë³¸ ê²½ë¡œ (ì—°í•œ ìƒ‰)
            if (showCorrectedPath && points.length > 1) {
                ctx.strokeStyle = 'rgba(100, 100, 100, 0.3)';
                ctx.lineWidth = 2;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.beginPath();
                points.forEach((point, i) => {
                    const { x, y } = toCanvas(point.lat, point.lon);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();
            }

            // í‘œì‹œ ê²½ë¡œ
            ctx.strokeStyle = showCorrectedPath ? '#10b981' : '#3b82f6';
            ctx.lineWidth = showCorrectedPath ? 6 : 4;
            ctx.lineCap = 'round';
            ctx.lineJoin = showCorrectedPath ? 'bevel' : 'miter';
            ctx.miterLimit = 4;
            ctx.beginPath();

            displayPoints.forEach((point, i) => {
                const { x, y } = toCanvas(point.lat, point.lon);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();

            // ì‹œì‘ì 
            const start = toCanvas(displayPoints[0].lat, displayPoints[0].lon);
            ctx.fillStyle = '#10b981';
            ctx.beginPath();
            ctx.arc(start.x, start.y, 10, 0, 2 * Math.PI);
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();

            // í˜„ì¬ ìœ„ì¹˜
            const end = toCanvas(displayPoints[displayPoints.length - 1].lat, displayPoints[displayPoints.length - 1].lon);
            ctx.fillStyle = '#ef4444';
            ctx.beginPath();
            ctx.arc(end.x, end.y, 12, 0, 2 * Math.PI);
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.restore();

            // ì¶•ì²™ ê³„ì‚°
            const metersPerPixel = (latRange * 111000) / (drawHeight * scale);
            updateScaleIndicator(metersPerPixel);
        }

        function updateScaleIndicator(metersPerPixel) {
            if (metersPerPixel === 0) {
                scaleIndicator.textContent = 'ì¶•ì²™: -';
                return;
            }
            
            let scaleValue, unit;
            if (metersPerPixel < 1) {
                scaleValue = (metersPerPixel * 100).toFixed(0);
                unit = 'cm/px';
            } else if (metersPerPixel < 1000) {
                scaleValue = metersPerPixel.toFixed(1);
                unit = 'm/px';
            } else {
                scaleValue = (metersPerPixel / 1000).toFixed(2);
                unit = 'km/px';
            }
            scaleIndicator.textContent = `${scaleValue}${unit}`;
        }

        // í†µê³„ ì—…ë°ì´íŠ¸
        function updateStats() {
            document.getElementById('pointCount').textContent = points.length;
            document.getElementById('distance').textContent = (totalDistance / 1000).toFixed(2) + 'km';
            
            if (startTime) {
                const elapsed = Math.floor((Date.now() - startTime) / 1000);
                const h = Math.floor(elapsed / 3600);
                const m = Math.floor((elapsed % 3600) / 60);
                const s = elapsed % 60;
                document.getElementById('time').textContent = 
                    `${h}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
            }
        }

        // ì—ëŸ¬ í‘œì‹œ
        function showError(message) {
            errorDiv.textContent = message;
            errorDiv.classList.remove('hidden');
        }

        function hideError() {
            errorDiv.classList.add('hidden');
        }

        // ì¶”ì  ì‹œì‘
        startBtn.addEventListener('click', () => {
            if (isTracking) {
                if (confirm('ì¶”ì ì„ ì¤‘ì§€í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\nê¸°ë¡ëœ ë°ì´í„°ëŠ” ìœ ì§€ë©ë‹ˆë‹¤.')) {
                    stopTracking();
                }
            } else {
                startTracking();
            }
        });

        function startTracking() {
            if (!navigator.geolocation) {
                showError('ì´ ê¸°ê¸°ëŠ” GPSë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
                return;
            }

            hideError();
            isTracking = true;
            startTime = Date.now();
            startBtn.textContent = 'â¸ ì¤‘ì§€';
            startBtn.classList.add('tracking');
            resetBtn.disabled = true;

            timerInterval = setInterval(updateStats, 1000);

            watchId = navigator.geolocation.watchPosition(
                (position) => {
                    const newPoint = {
                        lat: position.coords.latitude,
                        lon: position.coords.longitude,
                        timestamp: position.timestamp,
                        accuracy: position.coords.accuracy
                    };

                    locationInfo.classList.remove('hidden');
                    locationText.innerHTML = `
                        ìœ„ë„: ${newPoint.lat.toFixed(6)}Â°<br>
                        ê²½ë„: ${newPoint.lon.toFixed(6)}Â°<br>
                        ì •í™•ë„: Â±${newPoint.accuracy.toFixed(0)}m
                    `;

                    let shouldRecord = false;
                    
                    if (points.length === 0) {
                        shouldRecord = true;
                    } else {
                        const last = points[points.length - 1];
                        const dist = calculateDistance(last.lat, last.lon, newPoint.lat, newPoint.lon);
                        
                        if (dist >= 2 || (dist >= 1 && newPoint.accuracy < 10)) {
                            totalDistance += dist;
                            shouldRecord = true;
                        }
                    }

                    if (shouldRecord) {
                        points.push(newPoint);
                        drawPath();
                        updateStats();
                        downloadBtn.disabled = false;
                        console.log('GPS ìœ„ì¹˜ ê¸°ë¡:', newPoint, 'ì  ê°œìˆ˜:', points.length);
                    }
                },
                (error) => {
                    console.error('GPS ì—ëŸ¬:', error);
                    showError(`GPS ì˜¤ë¥˜: ${error.message} (ì½”ë“œ: ${error.code})`);
                    stopTracking();
                },
                {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 0
                }
            );
        }

        function stopTracking() {
            if (watchId !== null) {
                navigator.geolocation.clearWatch(watchId);
                watchId = null;
            }
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            isTracking = false;
            startBtn.textContent = 'â–¶ ì‹œì‘';
            startBtn.classList.remove('tracking');
            resetBtn.disabled = false;
        }

        // ë¦¬ì…‹
        resetBtn.addEventListener('click', () => {
            if (confirm('ëª¨ë“  ë°ì´í„°ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                stopTracking();
                points = [];
                totalDistance = 0;
                startTime = null;
                scale = 1;
                offsetX = 0;
                offsetY = 0;
                locationInfo.classList.add('hidden');
                downloadBtn.disabled = true;
                drawPath();
                updateStats();
                hideError();
            }
        });

        // ë‹¤ìš´ë¡œë“œ
        downloadBtn.addEventListener('click', () => {
            const data = {
                rawPoints: points,
                correctedPoints: simplifyPath(points, 0.00003),
                stats: {
                    distance: totalDistance,
                    pointCount: points.length,
                    duration: startTime ? Math.floor((Date.now() - startTime) / 1000) : 0
                },
                exportTime: new Date().toISOString()
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `gps-track-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        });

        // í˜ì´ì§€ ë– ë‚  ë•Œ ê²½ê³ 
        window.addEventListener('beforeunload', (e) => {
            if (isTracking || points.length > 0) {
                e.preventDefault();
                e.returnValue = '';
            }
        });

        // ì´ˆê¸° ê·¸ë¦¬ê¸°
        drawPath();
        updateStats();

        console.log('GPS ì¶”ì ê¸° ì¤€ë¹„ ì™„ë£Œ');
        console.log('Geolocation ì§€ì›:', !!navigator.geolocation);
    </script>
</body>
</html>
