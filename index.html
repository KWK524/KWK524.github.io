<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>GPS ê²½ë¡œ ì¶”ì ê¸° v1.4</title>
  <style>
    *{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent}
    body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;background:#111;color:#fff;overflow:hidden;height:100vh;display:flex;flex-direction:column}
    #header{background:#1f2937;padding:1rem;text-align:center;box-shadow:0 2px 8px rgba(0,0,0,.3)}
    h1{font-size:1.5rem;font-weight:700}
    #main{flex:1;display:flex;flex-direction:column;padding:1rem;gap:1rem;overflow-y:auto}
    #canvas-container{background:#1f2937;border-radius:.5rem;overflow:hidden;flex:1;min-height:300px;position:relative;touch-action:none}
    canvas{width:100%;height:100%;display:block}
    #scale-indicator{position:absolute;bottom:10px;right:10px;background:rgba(0,0,0,.7);padding:.5rem;border-radius:.25rem;font-size:.75rem;font-family:monospace;pointer-events:none;white-space:nowrap}
    .stats{display:grid;grid-template-columns:repeat(3,1fr);gap:.75rem}
    .stat-card{background:#1f2937;padding:.75rem;border-radius:.5rem}
    .stat-label{font-size:.75rem;color:#9ca3af;margin-bottom:.25rem}
    .stat-value{font-size:1.25rem;font-weight:700}
    .location-info{background:#1f2937;padding:.75rem;border-radius:.5rem;font-size:.875rem;font-family:monospace}
    .location-label{color:#9ca3af;margin-bottom:.25rem}
    .toggle-container{display:flex;align-items:center;justify-content:space-between;background:#1f2937;padding:.75rem;border-radius:.5rem}
    .toggle-label{font-size:.875rem;color:#9ca3af}
    .toggle-switch{position:relative;width:50px;height:26px;background:#374151;border-radius:13px;cursor:pointer;transition:background .3s}
    .toggle-switch.active{background:#3b82f6}
    .toggle-slider{position:absolute;top:3px;left:3px;width:20px;height:20px;background:#fff;border-radius:50%;transition:transform .3s}
    .toggle-switch.active .toggle-slider{transform:translateX(24px)}
    .controls{display:grid;grid-template-columns:2fr 1fr;gap:.75rem}
    button{padding:1rem;border:none;border-radius:.5rem;font-size:1.125rem;font-weight:600;cursor:pointer;transition:all .2s;display:flex;align-items:center;justify-content:center;gap:.5rem}
    button:active{transform:scale(.98)}
    #startBtn{background:#10b981;color:#fff}
    #startBtn:active{background:#059669}
    #startBtn.tracking{background:#ef4444}
    #startBtn.tracking:active{background:#dc2626}
    #resetBtn{background:#374151;color:#fff}
    #resetBtn:active{background:#4b5563}
    #resetBtn:disabled{background:#1f2937;color:#6b7280;cursor:not-allowed}
    #downloadBtn{background:#3b82f6;color:#fff;grid-column:1 / -1}
    #downloadBtn:active{background:#2563eb}
    #downloadBtn:disabled{background:#1f2937;color:#6b7280;cursor:not-allowed}
    .error{background:rgba(239,68,68,.2);border:1px solid #ef4444;color:#fca5a5;padding:.75rem;border-radius:.5rem;font-size:.875rem}
    .warn{background:rgba(245,158,11,.15);border:1px solid rgba(245,158,11,.7);color:#fcd34d;padding:.75rem;border-radius:.5rem;font-size:.875rem}
    .info{background:#1f2937;padding:.75rem;border-radius:.5rem;font-size:.75rem;color:#9ca3af}
    .info strong{color:#fff}
    .hidden{display:none}
  </style>
</head>
<body>
  <div id="header"><h1>ğŸ“ GPS ê²½ë¡œ ì¶”ì ê¸°</h1></div>

  <div id="main">
    <div id="canvas-container">
      <canvas id="canvas"></canvas>
      <div id="scale-indicator">ì¶•ì²™: -</div>
    </div>

    <div class="toggle-container">
      <span class="toggle-label">ë³´ì •ëœ ê²½ë¡œ í‘œì‹œ</span>
      <div id="togglePath" class="toggle-switch active" role="switch" aria-checked="true" aria-label="ë³´ì •ëœ ê²½ë¡œ í‘œì‹œ í† ê¸€">
        <div class="toggle-slider"></div>
      </div>
    </div>

    <div class="stats">
      <div class="stat-card">
        <div class="stat-label">ê¸°ë¡ì </div>
        <div class="stat-value" id="pointCount">0</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">ê±°ë¦¬</div>
        <div class="stat-value" id="distance">0.00km</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">ì‹œê°„</div>
        <div class="stat-value" id="time">0:00:00</div>
      </div>
    </div>

    <div id="locationInfo" class="location-info hidden">
      <div class="location-label">í˜„ì¬ ìœ„ì¹˜</div>
      <div id="locationText"></div>
    </div>

    <div class="controls">
      <button id="startBtn" aria-label="ì¶”ì  ì‹œì‘/ì¤‘ì§€">â–¶ ì‹œì‘</button>
      <button id="resetBtn" disabled aria-label="ë°ì´í„° ì´ˆê¸°í™”">â†»</button>
    </div>

    <button id="downloadBtn" disabled aria-label="ë°ì´í„° ì €ì¥">ğŸ’¾ ë°ì´í„° ì €ì¥</button>

    <div id="error" class="error hidden"></div>
    <div id="warn" class="warn hidden"></div>

    <div class="info">
      <strong>ğŸ’¡ ì‚¬ìš© íŒ</strong><br />
      â€¢ ìº”ë²„ìŠ¤: í•€ì¹˜/íœ ë¡œ í™•ëŒ€Â·ì¶•ì†Œ, ë“œë˜ê·¸ë¡œ ì´ë™<br />
      â€¢ ë…¹ìƒ‰=ì‹œì‘ì , ë¹¨ê°•=í˜„ì¬ìœ„ì¹˜<br />
      â€¢ ë³´ì • ê²½ë¡œ: ë‹¨ìˆœí™” + ì½”ë„ˆ ê°•ì¡° + (ê°€ëŠ¥í•œ ë²”ìœ„ì—ì„œ) ì§êµ ìŠ¤ëƒ… + êµì°¨ì  í‘œì‹œ
    </div>
  </div>

  <script>
    // =========================
    // ì„¤ì •(í˜„ì¥ í™˜ê²½ì— ë§ê²Œ ì¡°ì •)
    // =========================
    const CFG = {
      // í’ˆì§ˆ í•„í„°
      maxAccuracyM: 25,          // ì´ ê°’ë³´ë‹¤ accuracyê°€ í¬ë©´ ëˆ„ì /ê¸°ë¡ì—ì„œ ì œì™¸(íŠ ë°©ì§€)
      maxJumpSpeedMps: 20,       // ë¹„ì •ìƒ ì í”„ ì œê±°(ì´ˆë‹¹ 20m ì´ìƒ â‰’ 72km/h ì´ìƒ) í•„ìš” ì‹œ ìƒí–¥
      minDtForSpeedCheckS: 0.5,  // ë„ˆë¬´ ì§§ì€ dtëŠ” speed ê³„ì‚° ì•ˆì •ì„± ë‚®ì•„ì„œ ì œì™¸

      // ê¸°ë¡(ìƒ˜í”Œë§) ì¡°ê±´
      recordMinMoveM: 2,         // ê¸°ë³¸ 2m ì´ìƒ ì´ë™ ì‹œ ê¸°ë¡
      recordMinMoveAccGoodM: 1,  // ì •í™•ë„ ì¢‹ì„ ë•Œ(accuracy<10m) 1m ì´ìƒë„ ê¸°ë¡
      goodAccuracyM: 10,

      // ë³´ì •(ë‹¨ìˆœí™”/ì½”ë„ˆ/ì§êµìŠ¤ëƒ…)
      simplifyToleranceM: 4.0,   // RDP tolerance(ë¯¸í„° ë‹¨ìœ„)
      cornerAngleDeg: 35,        // ì½”ë„ˆë¡œ íŒë‹¨í•  ë°©í–¥ ë³€í™”(ê°ë„) ê¸°ì¤€
      snapToOrthogonalDeg: 20,   // 0/90/180/270ì— ê°€ê¹Œìš°ë©´ ìŠ¤ëƒ…(ì´ ê°ë„ ì´ë‚´)
      enableOrthogonalSnap: true,
      enableIntersectionMarks: true,

      // ë Œë” ìŠ¤ë¡œí‹€
      renderFps: 30
    };

    // =========================
    // ìƒíƒœ
    // =========================
    let isTracking = false;

    // ê¸°ë¡ìš© ì (í‘œì‹œ/ì €ì¥ rawPoints)
    let points = [];

    // ëˆ„ì  ê±°ë¦¬ìš© ë§ˆì§€ë§‰ "ìœ íš¨" ì (ê¸°ë¡ ì—¬ë¶€ì™€ ë¬´ê´€í•˜ê²Œ ì—…ë°ì´íŠ¸)
    let lastAccumPoint = null;

    // ê¸°ë¡ìš© ë§ˆì§€ë§‰ ì (ìƒ˜í”Œë§ ê¸°ì¤€ì )
    let lastRecordedPoint = null;

    let watchId = null;
    let startTime = null;
    let timerInterval = null;

    let totalDistance = 0; // meters

    // UI í† ê¸€(ê¸°ë³¸ true)
    let showCorrectedPath = true;

    // ìº”ë²„ìŠ¤ ì œì–´
    let scale = 1;
    let offsetX = 0;
    let offsetY = 0;
    let isDragging = false;
    let lastTouchX = 0;
    let lastTouchY = 0;

    // í•€ì¹˜
    let isPinching = false;
    let lastPinchDist = 0;
    let lastPinchCenter = null;

    // ë Œë” ìŠ¤ë¡œí‹€
    let rafPending = false;
    let lastRenderTs = 0;

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    const startBtn = document.getElementById('startBtn');
    const resetBtn = document.getElementById('resetBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const errorDiv = document.getElementById('error');
    const warnDiv = document.getElementById('warn');
    const locationInfo = document.getElementById('locationInfo');
    const locationText = document.getElementById('locationText');
    const togglePath = document.getElementById('togglePath');
    const scaleIndicator = document.getElementById('scale-indicator');

    // =========================
    // ìœ í‹¸
    // =========================
    function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
    function toRad(d) { return d * Math.PI / 180; }
    function toDeg(r) { return r * 180 / Math.PI; }

    // Haversine ê±°ë¦¬(ë¯¸í„°)
    function haversineMeters(lat1, lon1, lat2, lon2) {
      const R = 6371e3;
      const Ï†1 = toRad(lat1), Ï†2 = toRad(lat2);
      const Î”Ï† = toRad(lat2 - lat1);
      const Î”Î» = toRad(lon2 - lon1);
      const a = Math.sin(Î”Ï†/2)**2 + Math.cos(Ï†1)*Math.cos(Ï†2)*Math.sin(Î”Î»/2)**2;
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }

    // ë¡œì»¬ í‰ë©´ ë³€í™˜(equirectangular) : (lat,lon) -> meters (x,y) ê¸°ì¤€ì  (lat0, lon0)
    function projectMeters(lat, lon, lat0, lon0) {
      const R = 6371e3;
      const Ï† = toRad(lat);
      const Ï†0 = toRad(lat0);
      const Î» = toRad(lon);
      const Î»0 = toRad(lon0);
      const x = (Î» - Î»0) * Math.cos((Ï† + Ï†0) / 2) * R;
      const y = (Ï† - Ï†0) * R;
      return { x, y };
    }

    function unprojectMeters(x, y, lat0, lon0) {
      const R = 6371e3;
      const Ï†0 = toRad(lat0);
      const Î»0 = toRad(lon0);
      const Ï† = y / R + Ï†0;
      const Î» = x / (R * Math.cos((Ï† + Ï†0) / 2)) + Î»0;
      return { lat: toDeg(Ï†), lon: toDeg(Î») };
    }

    function headingDeg(a, b, lat0, lon0) {
      const A = projectMeters(a.lat, a.lon, lat0, lon0);
      const B = projectMeters(b.lat, b.lon, lat0, lon0);
      const dx = B.x - A.x;
      const dy = B.y - A.y;
      const ang = Math.atan2(dy, dx); // -pi..pi
      let deg = (toDeg(ang) + 360) % 360;
      return deg;
    }

    function angleDiffDeg(a, b) {
      let d = Math.abs(a - b) % 360;
      if (d > 180) d = 360 - d;
      return d;
    }

    // =========================
    // RDP(ë¯¸í„° ê¸°ë°˜) - ì•ˆì • êµ¬í˜„(mask ë°©ì‹)
    // =========================
    function rdpSimplifyMeters(pointsLL, toleranceM) {
      if (!pointsLL || pointsLL.length <= 2) return pointsLL ? pointsLL.slice() : [];
      const lat0 = pointsLL[0].lat;
      const lon0 = pointsLL[0].lon;

      const pts = pointsLL.map(p => {
        const m = projectMeters(p.lat, p.lon, lat0, lon0);
        return { ...p, _x: m.x, _y: m.y };
      });

      const keep = new Array(pts.length).fill(false);
      keep[0] = true;
      keep[pts.length - 1] = true;

      function perpDist(i, a, b) {
        const px = pts[i]._x, py = pts[i]._y;
        const ax = pts[a]._x, ay = pts[a]._y;
        const bx = pts[b]._x, by = pts[b]._y;
        const dx = bx - ax, dy = by - ay;
        const len2 = dx*dx + dy*dy;
        if (len2 === 0) return Math.hypot(px - ax, py - ay);
        const t = ((px - ax)*dx + (py - ay)*dy) / len2;
        const cx = ax + t*dx;
        const cy = ay + t*dy;
        return Math.hypot(px - cx, py - cy);
      }

      function simplifyRec(a, b) {
        let maxD = 0;
        let idx = -1;
        for (let i = a + 1; i < b; i++) {
          const d = perpDist(i, a, b);
          if (d > maxD) { maxD = d; idx = i; }
        }
        if (idx !== -1 && maxD > toleranceM) {
          keep[idx] = true;
          simplifyRec(a, idx);
          simplifyRec(idx, b);
        }
      }

      simplifyRec(0, pts.length - 1);

      const out = [];
      for (let i = 0; i < pts.length; i++) {
        if (keep[i]) {
          const { _x, _y, ...rest } = pts[i];
          out.push(rest);
        }
      }
      return out;
    }

    // =========================
    // ì½”ë„ˆ ê°•ì¡° + (ê°€ëŠ¥í•˜ë©´) ì§êµ ìŠ¤ëƒ…
    // - ì§€ë„ ì—†ì´ êµì°¨ë¡œ "ì •ë‹µ"ì€ ë¶ˆê°€í•˜ë¯€ë¡œ, ê·œì¹™ ê¸°ë°˜ìœ¼ë¡œ í˜•íƒœë§Œ ì •ë¦¬
    // =========================
    function enhanceCornersAndSnap(pointsLL) {
      if (!pointsLL || pointsLL.length <= 2) return pointsLL ? pointsLL.slice() : [];
      const lat0 = pointsLL[0].lat;
      const lon0 = pointsLL[0].lon;

      // 1) ë¡œì»¬ ì¢Œí‘œë¡œ ë³€í™˜
      const ptsM = pointsLL.map(p => {
        const m = projectMeters(p.lat, p.lon, lat0, lon0);
        return { ...p, x: m.x, y: m.y };
      });

      // 2) ì½”ë„ˆ(ë°©í–¥ ê¸‰ë³€) ê¸°ì¤€ìœ¼ë¡œ í¬ì¸íŠ¸ ìœ ì§€(ì¤‘ê°„ì  ì œê±°/ê°•ì¡°)
      const kept = [ptsM[0]];
      for (let i = 1; i < ptsM.length - 1; i++) {
        const a = ptsM[i-1], b = ptsM[i], c = ptsM[i+1];
        const ang1 = Math.atan2(b.y - a.y, b.x - a.x);
        const ang2 = Math.atan2(c.y - b.y, c.x - b.x);
        const d = angleDiffDeg(toDeg(ang1), toDeg(ang2));
        if (d >= CFG.cornerAngleDeg) kept.push(b);
      }
      kept.push(ptsM[ptsM.length - 1]);

      // 3) ì§êµ ìŠ¤ëƒ…: ì„¸ê·¸ë¨¼íŠ¸ ê°ë„ê°€ 0/90/180/270 ê·¼ì²˜ë©´ ìŠ¤ëƒ…
      if (!CFG.enableOrthogonalSnap || kept.length <= 2) {
        return kept.map(p => {
          const ll = unprojectMeters(p.x, p.y, lat0, lon0);
          return { ...p, lat: ll.lat, lon: ll.lon };
        }).map(({ x, y, ...rest }) => rest);
      }

      // ëˆ„ì  ë°©ì‹ìœ¼ë¡œ ì„ ë¶„ë“¤ì„ "ê°€ê¹Œìš´ ì§êµ ë°©í–¥"ìœ¼ë¡œ ëŒë ¤ì„œ í¬ì¸íŠ¸ ì¬ìƒì„±
      const outM = [ { ...kept[0] } ];
      for (let i = 1; i < kept.length; i++) {
        const prev = outM[outM.length - 1];
        const cur = kept[i];

        const dx = cur.x - prev.x;
        const dy = cur.y - prev.y;
        const len = Math.hypot(dx, dy);
        if (len < 0.5) continue;

        const ang = (toDeg(Math.atan2(dy, dx)) + 360) % 360;
        const candidates = [0, 90, 180, 270];
        let best = ang, bestDiff = 1e9;
        for (const c of candidates) {
          const d = angleDiffDeg(ang, c);
          if (d < bestDiff) { bestDiff = d; best = c; }
        }

        if (bestDiff <= CFG.snapToOrthogonalDeg) {
          // ì§êµ ë°©í–¥ìœ¼ë¡œ íˆ¬ì˜
          const rad = toRad(best);
          const nx = Math.cos(rad);
          const ny = Math.sin(rad);
          const proj = dx * nx + dy * ny; // signed length along snapped direction
          const snapped = {
            ...cur,
            x: prev.x + proj * nx,
            y: prev.y + proj * ny
          };
          outM.push(snapped);
        } else {
          outM.push({ ...cur });
        }
      }

      // 4) ë‹¤ì‹œ ìœ„ê²½ë„ë¡œ
      const outLL = outM.map(p => {
        const ll = unprojectMeters(p.x, p.y, lat0, lon0);
        const { x, y, ...rest } = p;
        return { ...rest, lat: ll.lat, lon: ll.lon };
      });

      return outLL;
    }

    // =========================
    // ì„¸ê·¸ë¨¼íŠ¸ êµì°¨ì (ìì²´ êµì°¨) íƒì§€(í‘œì‹œìš©)
    // =========================
    function segmentIntersection(p1, p2, p3, p4) {
      // (x,y) in meters. returns {x,y} or null
      const x1=p1.x,y1=p1.y,x2=p2.x,y2=p2.y,x3=p3.x,y3=p3.y,x4=p4.x,y4=p4.y;
      const den = (x1-x2)*(y3-y4) - (y1-y2)*(x3-x4);
      if (Math.abs(den) < 1e-9) return null;
      const px = ((x1*y2-y1*x2)*(x3-x4) - (x1-x2)*(x3*y4-y3*x4)) / den;
      const py = ((x1*y2-y1*x2)*(y3-y4) - (y1-y2)*(x3*y4-y3*x4)) / den;

      function within(a,b,c){ return c >= Math.min(a,b)-1e-6 && c <= Math.max(a,b)+1e-6; }
      if (within(x1,x2,px) && within(y1,y2,py) && within(x3,x4,px) && within(y3,y4,py)) {
        return { x: px, y: py };
      }
      return null;
    }

    function findIntersectionsLL(pointsLL) {
      if (!CFG.enableIntersectionMarks || !pointsLL || pointsLL.length < 4) return [];
      const lat0 = pointsLL[0].lat;
      const lon0 = pointsLL[0].lon;
      const pts = pointsLL.map(p => {
        const m = projectMeters(p.lat, p.lon, lat0, lon0);
        return { x: m.x, y: m.y };
      });

      const hits = [];
      // ì¸ì ‘ ì„¸ê·¸ë¨¼íŠ¸ ì œì™¸(ê³µìœ ì  ë•Œë¬¸ì—)
      for (let i = 0; i < pts.length - 1; i++) {
        for (let j = i + 2; j < pts.length - 1; j++) {
          if (j === i + 1) continue;
          const inter = segmentIntersection(pts[i], pts[i+1], pts[j], pts[j+1]);
          if (inter) hits.push(inter);
        }
      }

      // ë„ˆë¬´ ê°€ê¹Œìš´ êµì°¨ì  ë³‘í•©
      const merged = [];
      const mergeDist = 3; // meters
      for (const h of hits) {
        let ok = true;
        for (const m of merged) {
          if (Math.hypot(h.x - m.x, h.y - m.y) < mergeDist) { ok = false; break; }
        }
        if (ok) merged.push(h);
      }

      return merged.map(m => unprojectMeters(m.x, m.y, lat0, lon0));
    }

    // =========================
    // ìº”ë²„ìŠ¤/ì…ë ¥
    // =========================
    function resizeCanvas() {
      const container = document.getElementById('canvas-container');
      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;
      requestDraw();
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    togglePath.addEventListener('click', () => {
      showCorrectedPath = !showCorrectedPath;
      togglePath.classList.toggle('active', showCorrectedPath);
      togglePath.setAttribute('aria-checked', showCorrectedPath ? 'true' : 'false');
      requestDraw();
    });

    function getTouchDistance(touches) {
      const dx = touches[0].clientX - touches[1].clientX;
      const dy = touches[0].clientY - touches[1].clientY;
      return Math.sqrt(dx*dx + dy*dy);
    }

    function getTouchCenter(touches) {
      return {
        x: (touches[0].clientX + touches[1].clientX) / 2,
        y: (touches[0].clientY + touches[1].clientY) / 2
      };
    }

    function zoomAt(screenX, screenY, newScale) {
      newScale = clamp(newScale, 0.5, 10);
      const oldScale = scale;
      if (newScale === oldScale) return;

      // í™”ë©´ ì¢Œí‘œ ê¸°ì¤€ìœ¼ë¡œ í™•ëŒ€ ì¤‘ì‹¬ ê³ ì •:
      // offsetì€ canvas ì¤‘ì‹¬ ê¸°ì¤€ translateì— ë”í•´ì§€ëŠ” ê°’ì´ë¯€ë¡œ,
      // í™•ëŒ€ ì „/í›„ì— í•´ë‹¹ screen pointì˜ "ì›”ë“œ" ìœ„ì¹˜ê°€ ìœ ì§€ë˜ë„ë¡ offsetì„ ë³´ì •
      const rect = canvas.getBoundingClientRect();
      const cx = rect.left + canvas.width / 2;
      const cy = rect.top + canvas.height / 2;

      const dx = screenX - cx;
      const dy = screenY - cy;

      // í™•ëŒ€ ì „ ì¤‘ì‹¬ ê¸°ì¤€ ìƒëŒ€ì¢Œí‘œë¥¼ scaleë¡œ ë‚˜ëˆ„ë©´ ì›”ë“œ ë‹¨ìœ„
      const worldX = (dx - offsetX) / oldScale;
      const worldY = (dy - offsetY) / oldScale;

      scale = newScale;

      // í™•ëŒ€ í›„ ë‹¤ì‹œ ê°™ì€ ì›”ë“œê°€ ê°™ì€ screenì— ì˜¤ë„ë¡ offset ì¬ê³„ì‚°
      offsetX = dx - worldX * scale;
      offsetY = dy - worldY * scale;

      requestDraw();
    }

    canvas.addEventListener('mousedown', (e) => {
      e.preventDefault();
      isDragging = true;
      lastTouchX = e.clientX;
      lastTouchY = e.clientY;
    });

    canvas.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      e.preventDefault();
      const dx = e.clientX - lastTouchX;
      const dy = e.clientY - lastTouchY;
      offsetX += dx;
      offsetY += dy;
      lastTouchX = e.clientX;
      lastTouchY = e.clientY;
      requestDraw();
    });

    window.addEventListener('mouseup', () => { isDragging = false; });

    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      if (e.touches.length === 2) {
        isPinching = true;
        lastPinchDist = getTouchDistance(e.touches);
        lastPinchCenter = getTouchCenter(e.touches);
        isDragging = false;
      } else if (e.touches.length === 1) {
        isDragging = true;
        isPinching = false;
        lastTouchX = e.touches[0].clientX;
        lastTouchY = e.touches[0].clientY;
      }
    }, { passive: false });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (isPinching && e.touches.length === 2) {
        const dist = getTouchDistance(e.touches);
        const center = getTouchCenter(e.touches);

        const ratio = dist / (lastPinchDist || dist);
        const newScale = scale * ratio;

        // pinch ì¤‘ì‹¬ ê¸°ì¤€ zoom
        zoomAt(center.x, center.y, newScale);

        lastPinchDist = dist;
        lastPinchCenter = center;
      } else if (isDragging && e.touches.length === 1) {
        const dx = e.touches[0].clientX - lastTouchX;
        const dy = e.touches[0].clientY - lastTouchY;
        offsetX += dx;
        offsetY += dy;
        lastTouchX = e.touches[0].clientX;
        lastTouchY = e.touches[0].clientY;
        requestDraw();
      }
    }, { passive: false });

    canvas.addEventListener('touchend', () => {
      isDragging = false;
      isPinching = false;
    });

    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      const delta = e.deltaY > 0 ? 0.9 : 1.1;
      zoomAt(e.clientX, e.clientY, scale * delta);
    }, { passive: false });

    // =========================
    // ë Œë” ìŠ¤ë¡œí‹€
    // =========================
    function requestDraw() {
      if (rafPending) return;
      rafPending = true;
      requestAnimationFrame((ts) => {
        rafPending = false;
        const minFrame = 1000 / CFG.renderFps;
        if (ts - lastRenderTs < minFrame) return;
        lastRenderTs = ts;
        drawPath();
      });
    }

    // =========================
    // ì¶•ì²™ ê³„ì‚°(ê°€ë¡œ/ì„¸ë¡œ ëª¨ë‘ ê³ ë ¤)
    // =========================
    function updateScaleIndicatorFromBounds(minLat, maxLat, minLon, maxLon, drawWidthPx, drawHeightPx) {
      if (!isFinite(minLat) || !isFinite(maxLat) || !isFinite(minLon) || !isFinite(maxLon)) {
        scaleIndicator.textContent = 'ì¶•ì²™: -';
        return;
      }
      const meanLat = (minLat + maxLat) / 2;
      const latMeters = Math.max(0, haversineMeters(minLat, minLon, maxLat, minLon));
      const lonMeters = Math.max(0, haversineMeters(meanLat, minLon, meanLat, maxLon));

      const mPerPxY = drawHeightPx > 0 ? (latMeters / drawHeightPx) / scale : 0;
      const mPerPxX = drawWidthPx > 0 ? (lonMeters / drawWidthPx) / scale : 0;

      const mpp = (mPerPxX && mPerPxY) ? Math.min(mPerPxX, mPerPxY) : (mPerPxX || mPerPxY || 0);

      if (!mpp) { scaleIndicator.textContent = 'ì¶•ì²™: -'; return; }

      let value, unit;
      if (mpp < 1) { value = (mpp * 100).toFixed(0); unit = 'cm/px'; }
      else if (mpp < 1000) { value = mpp.toFixed(1); unit = 'm/px'; }
      else { value = (mpp / 1000).toFixed(2); unit = 'km/px'; }

      scaleIndicator.textContent = `ì¶•ì²™: ${value}${unit}`;
    }

    // =========================
    // ê²½ë¡œ ê·¸ë¦¬ê¸°
    // =========================
    function drawPath() {
      const width = canvas.width;
      const height = canvas.height;

      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.fillStyle = '#1a1a1a';
      ctx.fillRect(0, 0, width, height);

      if (points.length === 0) {
        ctx.fillStyle = '#6b7280';
        ctx.font = '16px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('ì¶”ì ì„ ì‹œì‘í•˜ì„¸ìš”', width / 2, height / 2);
        scaleIndicator.textContent = 'ì¶•ì²™: -';
        return;
      }

      // í‘œì‹œ í¬ì¸íŠ¸ ìƒì„±: raw -> (RDP) -> ì½”ë„ˆ/ìŠ¤ëƒ…
      let displayPoints = points.slice();
      let correctedPoints = null;

      if (showCorrectedPath) {
        const simplified = rdpSimplifyMeters(displayPoints, CFG.simplifyToleranceM);
        const enhanced = enhanceCornersAndSnap(simplified);
        correctedPoints = enhanced;
        displayPoints = enhanced;
      }

      if (displayPoints.length === 1) {
        ctx.save();
        ctx.translate(offsetX, offsetY);
        ctx.scale(scale, scale);
        ctx.fillStyle = '#10b981';
        ctx.beginPath();
        ctx.arc(width / 2, height / 2, 10, 0, 2 * Math.PI);
        ctx.fill();
        ctx.restore();
        scaleIndicator.textContent = 'ì¶•ì²™: -';
        return;
      }

      // bounds
      const lats = displayPoints.map(p => p.lat);
      const lons = displayPoints.map(p => p.lon);
      const minLat = Math.min(...lats);
      const maxLat = Math.max(...lats);
      const minLon = Math.min(...lons);
      const maxLon = Math.max(...lons);

      const latRange = (maxLat - minLat) || 0.0005;
      const lonRange = (maxLon - minLon) || 0.0005;

      const padding = 30;
      const drawWidth = width - 2 * padding;
      const drawHeight = height - 2 * padding;

      function toCanvas(lat, lon) {
        const x = padding + ((lon - minLon) / lonRange) * drawWidth;
        const y = height - padding - ((lat - minLat) / latRange) * drawHeight;
        return { x, y };
      }

      // world transform(íŒ¬/ì¤Œ)
      ctx.save();
      ctx.translate(width / 2 + offsetX, height / 2 + offsetY);
      ctx.scale(scale, scale);
      ctx.translate(-width / 2, -height / 2);

      // ì›ë³¸ ê²½ë¡œ(ë³´ì • í‘œì‹œ ì¤‘ì¼ ë•Œ ë°°ê²½ìœ¼ë¡œ)
      if (showCorrectedPath && points.length > 1) {
        ctx.strokeStyle = 'rgba(100, 100, 100, 0.25)';
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.beginPath();
        for (let i = 0; i < points.length; i++) {
          const { x, y } = toCanvas(points[i].lat, points[i].lon);
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.stroke();
      }

      // í‘œì‹œ ê²½ë¡œ
      ctx.strokeStyle = showCorrectedPath ? '#10b981' : '#3b82f6';
      ctx.lineWidth = showCorrectedPath ? 6 : 4;
      ctx.lineCap = 'round';
      ctx.lineJoin = showCorrectedPath ? 'bevel' : 'miter';
      ctx.miterLimit = 3;
      ctx.beginPath();
      for (let i = 0; i < displayPoints.length; i++) {
        const { x, y } = toCanvas(displayPoints[i].lat, displayPoints[i].lon);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();

      // êµì°¨ì  í‘œì‹œ(ë³´ì • ê²½ë¡œ ê¸°ì¤€)
      if (showCorrectedPath && correctedPoints && correctedPoints.length >= 4 && CFG.enableIntersectionMarks) {
        const hits = findIntersectionsLL(correctedPoints);
        if (hits.length) {
          ctx.fillStyle = 'rgba(245, 158, 11, 0.95)'; // amber
          ctx.strokeStyle = 'rgba(255,255,255,0.9)';
          ctx.lineWidth = 1.5;
          for (const h of hits) {
            const { x, y } = toCanvas(h.lat, h.lon);
            ctx.beginPath();
            ctx.arc(x, y, 6, 0, 2*Math.PI);
            ctx.fill();
            ctx.stroke();
          }
        }
      }

      // ì‹œì‘ì 
      const start = toCanvas(displayPoints[0].lat, displayPoints[0].lon);
      ctx.fillStyle = '#10b981';
      ctx.beginPath();
      ctx.arc(start.x, start.y, 10, 0, 2 * Math.PI);
      ctx.fill();
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.stroke();

      // í˜„ì¬ ìœ„ì¹˜
      const end = toCanvas(displayPoints[displayPoints.length - 1].lat, displayPoints[displayPoints.length - 1].lon);
      ctx.fillStyle = '#ef4444';
      ctx.beginPath();
      ctx.arc(end.x, end.y, 12, 0, 2 * Math.PI);
      ctx.fill();
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.restore();

      updateScaleIndicatorFromBounds(minLat, maxLat, minLon, maxLon, drawWidth, drawHeight);
    }

    // =========================
    // í†µê³„
    // =========================
    function updateStats() {
      document.getElementById('pointCount').textContent = points.length;
      document.getElementById('distance').textContent = (totalDistance / 1000).toFixed(2) + 'km';

      if (startTime) {
        const elapsed = Math.floor((Date.now() - startTime) / 1000);
        const h = Math.floor(elapsed / 3600);
        const m = Math.floor((elapsed % 3600) / 60);
        const s = elapsed % 60;
        document.getElementById('time').textContent = `${h}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
      } else {
        document.getElementById('time').textContent = '0:00:00';
      }

      resetBtn.disabled = (points.length === 0) && !isTracking;
      downloadBtn.disabled = points.length === 0;
    }

    // =========================
    // ì—ëŸ¬/ê²½ê³ 
    // =========================
    function showError(message) {
      errorDiv.textContent = message;
      errorDiv.classList.remove('hidden');
    }
    function hideError() { errorDiv.classList.add('hidden'); }

    function showWarn(message) {
      warnDiv.textContent = message;
      warnDiv.classList.remove('hidden');
    }
    function hideWarn() { warnDiv.classList.add('hidden'); }

    // =========================
    // ì¶”ì  ì‹œì‘/ì¤‘ì§€
    // =========================
    startBtn.addEventListener('click', () => {
      if (isTracking) {
        if (confirm('ì¶”ì ì„ ì¤‘ì§€í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\nê¸°ë¡ëœ ë°ì´í„°ëŠ” ìœ ì§€ë©ë‹ˆë‹¤.')) stopTracking();
      } else {
        startTracking();
      }
    });

    function startTracking() {
      if (!navigator.geolocation) {
        showError('ì´ ê¸°ê¸°ëŠ” GPSë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
        return;
      }

      hideError();
      hideWarn();

      isTracking = true;

      // startTimeì€ "ì²˜ìŒ ì‹œì‘"ë§Œ ì¡ê³ , ì¤‘ì§€ í›„ ì¬ì‹œì‘ ì‹œ ìƒˆë¡œ ì‹œì‘í•˜ë„ë¡ ìœ ì§€(ì›í•˜ë©´ ëˆ„ì  ë°©ì‹ìœ¼ë¡œ ë°”ê¿”ë„ ë¨)
      startTime = Date.now();

      startBtn.textContent = 'â¸ ì¤‘ì§€';
      startBtn.classList.add('tracking');
      resetBtn.disabled = true;

      timerInterval = setInterval(updateStats, 1000);

      watchId = navigator.geolocation.watchPosition(
        onPosition,
        onGeoError,
        { enableHighAccuracy: true, timeout: 15000, maximumAge: 0 }
      );
    }

    function stopTracking() {
      if (watchId !== null) {
        navigator.geolocation.clearWatch(watchId);
        watchId = null;
      }
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
      isTracking = false;
      startBtn.textContent = 'â–¶ ì‹œì‘';
      startBtn.classList.remove('tracking');
      resetBtn.disabled = (points.length === 0);
      updateStats();
    }

    function onGeoError(error) {
      console.error('GPS ì—ëŸ¬:', error);

      // TIMEOUTì€ ì¼ì‹œì ì¼ ìˆ˜ ìˆìœ¼ë‹ˆ ì¶”ì  ìœ ì§€ + ê²½ê³ ë§Œ
      if (error && error.code === 3) {
        showWarn(`GPS ì§€ì—°: ${error.message} (ê³„ì† ì‹œë„ ì¤‘)`);
        return;
      }

      showError(`GPS ì˜¤ë¥˜: ${error.message} (ì½”ë“œ: ${error.code})`);
      stopTracking();
    }

    function isValidFix(p) {
      if (!p || !isFinite(p.lat) || !isFinite(p.lon)) return false;
      if (!isFinite(p.accuracy)) return false;
      if (p.accuracy > CFG.maxAccuracyM) return false;
      return true;
    }

    function passesJumpFilter(prev, cur) {
      if (!prev) return true;
      const dt = (cur.timestamp - prev.timestamp) / 1000;
      if (!isFinite(dt) || dt <= 0) return true;

      // ë„ˆë¬´ ì§§ì€ ê°„ê²©ì€ speed íŒë‹¨ì´ ë¶ˆì•ˆì •í•  ìˆ˜ ìˆìŒ
      if (dt < CFG.minDtForSpeedCheckS) return true;

      const d = haversineMeters(prev.lat, prev.lon, cur.lat, cur.lon);
      const speed = d / dt;

      // ë¸Œë¼ìš°ì €ê°€ speed ì œê³µí•˜ë©´ ì°¸ê³ (í•˜ì§€ë§Œ ì‹ ë¢°ë„ ë“¤ì­‰ë‚ ì­‰)
      const sp = (isFinite(cur.speed) && cur.speed >= 0) ? cur.speed : null;
      const effectiveSpeed = sp !== null ? Math.max(speed, sp) : speed;

      return effectiveSpeed <= CFG.maxJumpSpeedMps;
    }

    function onPosition(position) {
      const cur = {
        lat: position.coords.latitude,
        lon: position.coords.longitude,
        timestamp: position.timestamp,
        accuracy: position.coords.accuracy,
        speed: position.coords.speed
      };

      locationInfo.classList.remove('hidden');
      locationText.innerHTML = `
        ìœ„ë„: ${cur.lat.toFixed(6)}Â°<br>
        ê²½ë„: ${cur.lon.toFixed(6)}Â°<br>
        ì •í™•ë„: Â±${cur.accuracy.toFixed(0)}m
      `;

      // ì •í™•ë„/ì í”„ í•„í„°
      if (!isValidFix(cur)) {
        showWarn(`GPS ì •í™•ë„ ë‚®ìŒ(Â±${cur.accuracy.toFixed(0)}m) - ì¼ì‹œ ì œì™¸`);
        return;
      }
      if (!passesJumpFilter(lastAccumPoint, cur)) {
        showWarn('ë¹„ì •ìƒ ìœ„ì¹˜ ì í”„ ê°ì§€ - ì¼ì‹œ ì œì™¸');
        return;
      }
      hideWarn();

      // ëˆ„ì  ê±°ë¦¬: "ìœ íš¨í•œ fix"ëŠ” ê¸°ë¡ ì—¬ë¶€ì™€ ë¬´ê´€í•˜ê²Œ ëˆ„ì 
      if (lastAccumPoint) {
        const d = haversineMeters(lastAccumPoint.lat, lastAccumPoint.lon, cur.lat, cur.lon);
        // ë„ˆë¬´ ì‘ì€ ë…¸ì´ì¦ˆëŠ” ëˆ„ì  ì œì™¸(ë¯¸ì„¸ í”ë“¤ë¦¼)
        if (d >= 0.5) totalDistance += d;
      }
      lastAccumPoint = cur;

      // ê¸°ë¡(ìƒ˜í”Œë§): í‘œì‹œ/ì €ì¥ìš© pointsëŠ” ì¡°ê±´ ë§Œì¡± ì‹œì—ë§Œ push
      let shouldRecord = false;
      if (!lastRecordedPoint) {
        shouldRecord = true;
      } else {
        const dRec = haversineMeters(lastRecordedPoint.lat, lastRecordedPoint.lon, cur.lat, cur.lon);
        const minMove = (cur.accuracy < CFG.goodAccuracyM) ? CFG.recordMinMoveAccGoodM : CFG.recordMinMoveM;
        if (dRec >= minMove) shouldRecord = true;
      }

      if (shouldRecord) {
        points.push(cur);
        lastRecordedPoint = cur;

        downloadBtn.disabled = false;
        resetBtn.disabled = true;

        requestDraw();
        updateStats();
        console.log('GPS ê¸°ë¡:', cur, 'points:', points.length);
      } else {
        // ê¸°ë¡ì€ ì•ˆí•´ë„ ê±°ë¦¬/ì‹œê°„ì€ ê°±ì‹ ë˜ë¯€ë¡œ ìµœì†Œí•œ statsëŠ” ê°±ì‹ 
        updateStats();
      }
    }

    // =========================
    // ë¦¬ì…‹
    // =========================
    resetBtn.addEventListener('click', () => {
      if (confirm('ëª¨ë“  ë°ì´í„°ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
        stopTracking();
        points = [];
        totalDistance = 0;
        startTime = null;

        lastAccumPoint = null;
        lastRecordedPoint = null;

        scale = 1;
        offsetX = 0;
        offsetY = 0;

        locationInfo.classList.add('hidden');
        downloadBtn.disabled = true;
        resetBtn.disabled = true;

        hideError();
        hideWarn();

        requestDraw();
        updateStats();
      }
    });

    // =========================
    // ë‹¤ìš´ë¡œë“œ(iOS/Safari ì•ˆì •ì„± ê°œì„ )
    // =========================
    downloadBtn.addEventListener('click', () => {
      if (points.length === 0) return;

      const corrected = (() => {
        const simplified = rdpSimplifyMeters(points, CFG.simplifyToleranceM);
        return enhanceCornersAndSnap(simplified);
      })();

      const intersections = CFG.enableIntersectionMarks ? findIntersectionsLL(corrected) : [];

      const data = {
        rawPoints: points,
        correctedPoints: corrected,
        intersections: intersections,
        params: {
          maxAccuracyM: CFG.maxAccuracyM,
          maxJumpSpeedMps: CFG.maxJumpSpeedMps,
          recordMinMoveM: CFG.recordMinMoveM,
          recordMinMoveAccGoodM: CFG.recordMinMoveAccGoodM,
          simplifyToleranceM: CFG.simplifyToleranceM,
          cornerAngleDeg: CFG.cornerAngleDeg,
          snapToOrthogonalDeg: CFG.snapToOrthogonalDeg,
          enableOrthogonalSnap: CFG.enableOrthogonalSnap,
          enableIntersectionMarks: CFG.enableIntersectionMarks
        },
        stats: {
          distanceM: totalDistance,
          pointCount: points.length,
          durationS: startTime ? Math.floor((Date.now() - startTime) / 1000) : 0
        },
        exportTime: new Date().toISOString()
      };

      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);

      const a = document.createElement('a');
      a.href = url;
      a.download = `gps-track-${Date.now()}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);

      // revokeë¥¼ ë„ˆë¬´ ë¹¨ë¦¬ í•˜ë©´ ì¼ë¶€ ë¸Œë¼ìš°ì €ì—ì„œ ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨ ê°€ëŠ¥
      setTimeout(() => URL.revokeObjectURL(url), 2000);
    });

    // =========================
    // í˜ì´ì§€ ì´íƒˆ ê²½ê³ 
    // =========================
    window.addEventListener('beforeunload', (e) => {
      if (isTracking || points.length > 0) {
        e.preventDefault();
        e.returnValue = '';
      }
    });

    // =========================
    // ì´ˆê¸° ìƒíƒœ
    // =========================
    requestDraw();
    updateStats();

    console.log('GPS ì¶”ì ê¸° ì¤€ë¹„ ì™„ë£Œ');
    console.log('Geolocation ì§€ì›:', !!navigator.geolocation);
  </script>
</body>
</html>
